"""
基本文本文件切块策略

此策略适用于纯文本文件(.txt)，按照行和字符数进行切块。
"""
from typing import List, Dict, Any
import logging
from .base import BaseChunkStrategy
from .registry import register_strategy

# 设置日志
logger = logging.getLogger(__name__)

@register_strategy
class TextChunkStrategy(BaseChunkStrategy):
    """文本文件切块策略"""
    
    def __init__(self):
        """初始化策略"""
        self.current_section = "默认章节"
    
    def chunk(self, file_path: str, chunk_size: int, overlap: int) -> List[str]:
        """
        按照指定大小切分文本文件
        
        Args:
            file_path: 文本文件路径
            chunk_size: 每个块的大小（字符数）
            overlap: 相邻块之间的重叠字符数
            
        Returns:
            切分后的文本块列表
        """
        # 调用chunk_with_metadata，但只返回内容部分
        chunks_with_meta = self.chunk_with_metadata(file_path, chunk_size, overlap)
        return [chunk["content"] for chunk in chunks_with_meta]
    
    def chunk_with_metadata(self, file_path: str, chunk_size: int, overlap: int) -> List[Dict[str, Any]]:
        """
        按照指定大小切分文本文件，返回包含内容和元数据的结果
        
        Args:
            file_path: 文本文件路径
            chunk_size: 每个块的大小（字符数）
            overlap: 相邻块之间的重叠字符数
            
        Returns:
            包含内容和元数据的文本块列表
        """
        try:
            # 读取文本文件
            with open(file_path, 'r', encoding='utf-8') as file:
                text = file.read()
            
            # 初始化结果
            result_chunks = []
            
            # 按行分割
            lines = text.split('\n')
            
            current_chunk_lines = []
            current_size = 0
            
            # 识别章节标题的函数
            def is_section_title(line):
                # 简单判断：以#开头或长度小于50且以冒号结尾的行
                return line.strip().startswith('#') or (len(line.strip()) < 50 and line.strip().endswith(':'))
            
            for line in lines:
                # 检查是否是章节标题
                if is_section_title(line):
                    # 如果当前chunk不为空，先输出
                    if current_chunk_lines:
                        result_chunks.append(self._create_chunk(current_chunk_lines, self.current_section))
                        current_chunk_lines = []
                        current_size = 0
                    
                    # 更新当前章节
                    self.current_section = line.strip()
                    continue
                
                # 如果添加这行会超过chunk_size，且当前chunk不为空，先输出当前chunk
                if current_size + len(line) > chunk_size and current_chunk_lines:
                    result_chunks.append(self._create_chunk(current_chunk_lines, self.current_section))
                    
                    # 如果需要重叠，则保留部分行
                    if overlap > 0:
                        # 计算保留多少行才能达到overlap
                        overlap_size = 0
                        overlap_lines = []
                        for l in reversed(current_chunk_lines):
                            if overlap_size + len(l) <= overlap:
                                overlap_lines.insert(0, l)
                                overlap_size += len(l)
                            else:
                                break
                        
                        current_chunk_lines = overlap_lines
                        current_size = overlap_size
                    else:
                        current_chunk_lines = []
                        current_size = 0
                
                # 如果行本身就超过chunk_size，分段处理
                if len(line) > chunk_size:
                    # 处理长行
                    line_chunks = self._chunk_long_text(line, chunk_size, overlap)
                    for l_chunk in line_chunks:
                        result_chunks.append(self._create_chunk([l_chunk], self.current_section))
                else:
                    # 正常添加行
                    current_chunk_lines.append(line)
                    current_size += len(line)
            
            # 处理最后一个chunk
            if current_chunk_lines:
                result_chunks.append(self._create_chunk(current_chunk_lines, self.current_section))
            
            return result_chunks
            
        except Exception as e:
            logger.error(f"切块过程中发生错误: {str(e)}")
            raise
    
    def _chunk_long_text(self, text: str, chunk_size: int, overlap: int) -> List[str]:
        """
        将长文本分割成多个块
        
        Args:
            text: 长文本
            chunk_size: 每个块的大小
            overlap: 重叠大小
            
        Returns:
            分割后的文本块列表
        """
        chunks = []
        start = 0
        
        while start < len(text):
            end = min(start + chunk_size, len(text))
            
            # 避免在单词中间切断
            if end < len(text) and not text[end].isspace():
                # 向后查找空格
                space_pos = text.find(' ', end)
                if space_pos != -1 and space_pos - end < 20:  # 最多向后查找20个字符
                    end = space_pos
            
            chunks.append(text[start:end])
            
            # 考虑重叠
            start = end - overlap if overlap > 0 else end
        
        return chunks
    
    def _create_chunk(self, lines: List[str], section: str) -> Dict[str, Any]:
        """
        创建包含内容和元数据的块
        
        Args:
            lines: 文本行列表
            section: 当前章节
            
        Returns:
            包含内容和元数据的字典
        """
        content = '\n'.join(lines)
        return {
            "content": content,
            "meta": {
                "section": section,
                "line_count": len(lines),
                "char_count": len(content)
            }
        }
    
    def get_metadata(self) -> Dict[str, Any]:
        """
        获取切块策略的元数据
        
        Returns:
            包含策略信息的字典
        """
        return {
            "name": "text",
            "description": "TXT纯文本文件切块策略",
            "supported_types": [".txt"]
        } 